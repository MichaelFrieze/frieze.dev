import { ArticleLayout } from "@/components/ArticleLayout";

export const article = {
  author: "Michael Frieze",
  date: "2025-02-23",
  title: "Are React Server Components Fetch-on-Render or Render-as-You-Fetch?",
  description: `Exploring the nuances of fetch-on-render and render-as-you-fetch patterns in React Server Components.`,
};

export const metadata = {
  title: article.title,
  description: article.description,
};

export default (props) => <ArticleLayout article={article} {...props} />;

When it comes to data fetching in React Server Components (RSCs), the question arises: are they truly "render-as-you-fetch" as commonly described, or do they sometimes behave more like "fetch-on-render"? Let's explore this nuanced topic and examine how RSCs handle data fetching.

## The Traditional Client-Side Perspective

In client-side React, we typically think of data fetching strategies in two main categories:

1. **Render-as-you-fetch**: In this pattern, data fetching is initiated before rendering begins. The idea here is that "fetch triggers render." Data fetching is typically hoisted to the top of the component tree, allowing for parallel data loading and rendering. Components can start rendering immediately, potentially showing loading states while waiting for data.
2. **Fetch-on-render**: This pattern is characterized by the idea that "render triggers fetch." Each component is responsible for its own data fetching, and the component's rendering logic initiates the data fetch. Data fetching is colocated within the client component, making the code more modular and self-contained. However, this can potentially lead to waterfall effects, especially in nested component structures.

## Server Components: A Hybrid Approach

When we look closely at how RSCs operate, we can see characteristics of both patterns:

### Fetch-on-render Characteristics:

- **Colocated Data Fetching**: RSCs allow (and often encourage) colocating data fetching within components, similar to client-side fetch-on-render patterns.
- **Potential for Server-side Waterfalls**: Nested components that each fetch their own data can create sequential data fetching on the server, resembling a waterfall effect.

### Render-as-you-fetch Characteristics:

- **Parallel Rendering**: Layouts and pages in the App Router are rendered in parallel, enabling concurrent data requests.
- **Single Client Request**: From the client's perspective, all server-side data fetching happens in a single request, eliminating client-side waterfalls.

## The Power of Colocated Data Fetching in RSCs

Colocating data fetching within server components is not only okay but often recommended. Unlike client-side waterfalls, server-side waterfalls are generally less problematic for several reasons:

1. **Server Performance**: Servers typically have faster processing power and network connections, minimizing the impact of sequential data fetching. Additionally, servers are physically closer to the database, resulting in lower latency for data retrieval.
2. **Single Round Trip**: All server-side operations happen in a single request-response cycle from the client's perspective.
3. **Improved Code Organization**: Colocated data fetching often leads to more maintainable and understandable code.

While it's good to be aware of potential server-side waterfalls, in most cases, the benefits of colocated data fetching outweigh the drawbacks. The server's proximity to data sources and the ability to optimize server-side connections make these waterfalls less impactful on overall performance compared to client-side waterfalls.

## Optimizing Data Fetching in RSCs

For cases where you do want to optimize and avoid server-side waterfalls, consider these strategies:

1. **Use Promise.all**: Within a single component, leverage `Promise.all` to fetch multiple data sources in parallel.
2. **Hoist Data Fetching**: When necessary, consider fetching data higher in the component tree and passing it down as props.
3. **Leverage Layout and Page Parallelism**: Take advantage of the App Router's ability to render layouts and pages concurrently.

## The Client-Side Perspective

It's crucial to remember that regardless of the server-side implementation, the client experiences RSCs differently:

- RSCs arrive at the client as pre-executed components.
- They don't block the execution of client components.
- From the client's view, it's more accurate to say that "fetch triggers render" rather than "render triggers fetch."

## Conclusion

So, are React Server Components fetch-on-render or render-as-you-fetch? The answer is: they can be both, depending on how you implement them. RSCs provide the flexibility to colocate data fetching for better code organization while also offering tools to optimize and parallelize data loading when needed.
